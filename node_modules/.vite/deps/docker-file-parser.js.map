{
  "version": 3,
  "sources": ["../../docker-file-parser/parser.js", "../../docker-file-parser/index.js"],
  "sourcesContent": ["// parser.js\n\n/**\n * This package implements a Dockerfile parser.\n *\n * This is a translation of the docker go parser at:\n * https://github.com/docker/docker/blob/master/builder/parser/parser.go\n */\n\n\nvar TOKEN_WHITESPACE        = RegExp(/[\\t\\v\\f\\r ]+/);\nvar TOKEN_LINE_CONTINUATION = RegExp(/\\\\[ \\t]*$/);\nvar TOKEN_COMMENT           = RegExp(/^\\s*#.*$/);\nvar TOKEN_ESCAPE_DIRECTIVE  = RegExp(/^#[ \\t]*escape[ \\t]*=[ \\t]*(.).*$/);\n\nvar errDockerfileNotStringArray = new Error('When using JSON array syntax, '\n                                + 'arrays must be comprised of strings only.');\n\n\nfunction isSpace(s) {\n    return s.match(/^\\s$/);\n}\n\n// Escape special regular expression characters in the provided string.\nfunction regexEscape(str) {\n    return str.replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"\\\\$&\");\n}\n\n/**\n * Parsers are dispatch calls that parse a single unit of text into a cmd.args\n * object which contains the statement details. Dockerfiles have varied (but not\n * usually unique, see ONBUILD for a unique example) parsing rules per-command,\n * and these unify the processing in a way that makes it manageable.\n */\n\n// Parse onbuild, could potentially be used for anything that represents a\n// statement with sub-statements.\n//\n// ONBUILD RUN foo bar -> (onbuild (run foo bar))\n//\nfunction parseSubCommand(cmd) {\n    var parseDetails = parseLine(cmd.rest, cmd.lineno);\n    if (parseDetails.command) {\n        cmd.args = parseDetails.command;\n        return true;\n    }\n    cmd.error = 'Unhandled onbuild command: ' + cmd.rest;\n    return false;\n}\n\n// Helper to parse words (i.e space delimited or quoted strings) in a statement.\n// The quotes are preserved as part of this function and they are stripped later\n// as part of processWords().\nfunction parseWords(rest) {\n    var S_inSpaces = 1;\n    var S_inWord   = 2;\n    var S_inQuote  = 3;\n\n    var words = [];\n    var phase = S_inSpaces;\n    var word = '';\n    var quote = '';\n    var blankOK = false;\n    var ch;\n    var pos;\n\n    for (pos = 0; pos <= rest.length; pos++) {\n        if (pos != rest.length) {\n            ch = rest[pos];\n        }\n\n        if (phase == S_inSpaces) { // Looking for start of word\n            if (pos == rest.length) { // end of input\n                break;\n            }\n            if (isSpace(ch)) { // skip spaces\n                continue;\n            }\n            phase = S_inWord; // found it, fall thru\n        }\n        if ((phase == S_inWord || phase == S_inQuote) && (pos == rest.length)) {\n            if (blankOK || word.length > 0) {\n                words.push(word);\n            }\n            break;\n        }\n        if (phase == S_inWord) {\n            if (isSpace(ch)) {\n                phase = S_inSpaces;\n                if (blankOK || word.length > 0) {\n                    words.push(word);\n                }\n                word = '';\n                blankOK = false;\n                continue;\n            }\n            if (ch == '\\'' || ch == '\"') {\n                quote = ch;\n                blankOK = true;\n                phase = S_inQuote;\n            }\n            if (ch == '\\\\') {\n                if (pos+1 == rest.length) {\n                    continue; // just skip \\ at end\n                }\n                // If we're not quoted and we see a \\, then always just\n                // add \\ plus the char to the word, even if the char\n                // is a quote.\n                word += ch;\n                pos++;\n                ch = rest[pos];\n            }\n            word += ch;\n            continue;\n        }\n        if (phase == S_inQuote) {\n            if (ch == quote) {\n                phase = S_inWord;\n            }\n            // \\ is special except for ' quotes - can't escape anything for '\n            if (ch == '\\\\' && quote != '\\'') {\n                if (pos+1 == rest.length) {\n                    phase = S_inWord;\n                    continue; // just skip \\ at end\n                }\n                word += ch;\n                pos++;\n                ch = rest[pos];\n            }\n            word += ch;\n        }\n    }\n\n    return words;\n}\n\n// Parse environment like statements. Note that this does *not* handle\n// variable interpolation, which will be handled in the evaluator.\nfunction parseNameVal(cmd) {\n    // This is kind of tricky because we need to support the old\n    // variant:   KEY name value\n    // as well as the new one:    KEY name=value ...\n    // The trigger to know which one is being used will be whether we hit\n    // a space or = first.  space ==> old, \"=\" ==> new\n    var word;\n    var words = parseWords(cmd.rest);\n\n    cmd.args = {};\n\n    if (words.length === 0) {\n        cmd.error = 'No KEY name value, or KEY name=value arguments found';\n        return false;\n    }\n\n    if (words[0].indexOf('=') == -1) {\n        // Old format (KEY name value)\n        var strs = cmd.rest.split(TOKEN_WHITESPACE);\n        if (strs.length < 2) {\n            cmd.error = cmd.name + ' must have two arguments, got ' + cmd.rest;\n            return false;\n        }\n\n        // Convert to new style key:value map.\n        cmd.args[strs[0]] = strs.slice(1).join(' ');\n\n    } else {\n        // New format (KEY name=value ...)\n        var i;\n        for (i = 0; i < words.length; i++) {\n            word = words[i];\n            if (word.indexOf('=') == -1) {\n                cmd.error = 'Syntax error - can\\'t find = in ' + word\n                    + '. Must be of the form: name=value';\n                return false;\n            }\n            var parts = word.split('=');\n            cmd.args[parts[0]] = parts.slice(1).join('=');\n        }\n    }\n\n    return true;\n}\n\nfunction parseEnv(cmd) {\n    return parseNameVal(cmd);\n}\n\nfunction parseLabel(cmd) {\n    return parseNameVal(cmd);\n}\n\n// Parses a statement containing one or more keyword definition(s) and/or\n// value assignments, like `name1 name2= name3=\"\" name4=value`.\n// Note that this is a stricter format than the old format of assignment,\n// allowed by parseNameVal(), in a way that this only allows assignment of the\n// form `keyword=[<value>]` like  `name2=`, `name3=\"\"`, and `name4=value` above.\n// In addition, a keyword definition alone is of the form `keyword` like `name1`\n// above. And the assignments `name2=` and `name3=\"\"` are equivalent and\n// assign an empty value to the respective keywords.\nfunction parseNameOrNameVal(cmd) {\n    cmd.args = parseWords(cmd.rest);\n    return true;\n}\n\n// Parses a whitespace-delimited set of arguments. The result is a\n// list of string arguments.\nfunction parseStringsWhitespaceDelimited(cmd) {\n    cmd.args = cmd.rest.split(TOKEN_WHITESPACE);\n    return true;\n}\n\n// Just stores the raw string.\nfunction parseString(cmd) {\n    cmd.args = cmd.rest;\n    return true;\n}\n\n// Converts to JSON array, returns true on success, false otherwise.\nfunction parseJSON(cmd) {\n    try {\n        var json = JSON.parse(cmd.rest);\n    } catch (e) {\n        return false;\n    }\n\n    // Ensure it's an array.\n    if (!Array.isArray(json)) {\n        return false;\n    }\n\n    // Ensure every entry in the array is a string.\n    if (!json.every(function (entry) {\n        return typeof (entry) === 'string';\n    })) {\n        return false;\n    }\n\n    cmd.args = json;\n    return true;\n}\n\n// Determines if the argument appears to be a JSON array. If so, passes to\n// parseJSON; if not, quotes the result and returns a single string.\nfunction parseJsonOrString(cmd) {\n    if (parseJSON(cmd)) {\n        return true;\n    }\n    return parseString(cmd);\n}\n\n// Determines if the argument appears to be a JSON array. If so, parses as JSON;\n// if not, attempts to parse it as a whitespace delimited string.\nfunction parseJsonOrList(cmd) {\n    if (parseJSON(cmd)) {\n        return true;\n    }\n    return parseStringsWhitespaceDelimited(cmd);\n}\n\n// Dispatch Table. see line_parsers.go for the parse functions.\n// The command is parsed and mapped to the line parser. The line parser\n// recieves the arguments but not the command, and returns an AST after\n// reformulating the arguments according to the rules in the parser\n// functions. Errors are propagated up by Parse() and the resulting AST can\n// be incorporated directly into the existing AST as a next.\nvar commandParsers = {\n    'ADD':        parseJsonOrList,\n    'ARG':        parseNameOrNameVal,\n    'CMD':        parseJsonOrString,\n    'COPY':       parseJsonOrList,\n    'ENTRYPOINT': parseJsonOrString,\n    'ENV':        parseEnv,\n    'EXPOSE':     parseStringsWhitespaceDelimited,\n    'FROM':       parseString,\n    'LABEL':      parseLabel,\n    'MAINTAINER': parseString,\n    'ONBUILD':    parseSubCommand,\n    'RUN':        parseJsonOrString,\n    'STOPSIGNAL': parseString,\n    'USER':       parseString,\n    'VOLUME':     parseJsonOrList,\n    'WORKDIR':    parseString\n};\n\nfunction isComment(line) {\n    return line.match(TOKEN_COMMENT);\n}\n\n// Takes a single line of text and parses out the cmd and rest,\n// which are used for dispatching to more exact parsing functions.\nfunction splitCommand(line) {\n    // Make sure we get the same results irrespective of leading/trailing spaces\n    var match = line.match(TOKEN_WHITESPACE);\n    if (!match) {\n        return { name: line.toUpperCase(), rest: '' };\n    }\n    var name = line.substr(0, match.index).toUpperCase();\n    var rest = line.substr(match.index + match[0].length);\n\n    return { name: name, rest: rest };\n}\n\n// parse a line and return the remainder.\nfunction parseLine(line, lineno, options) {\n    var command = null;\n    var lineContinuationRegex = (options && options.lineContinuationRegex\n        || TOKEN_LINE_CONTINUATION);\n\n    line = line.trim();\n\n    if (!line) {\n        // Ignore empty lines\n        return { command: null, remainder: '' };\n    }\n\n    if (isComment(line)) {\n        // Handle comment lines.\n        command = { name: 'COMMENT', args: line, lineno: lineno };\n        return { command: command, remainder: '' };\n    }\n\n    if (line.match(lineContinuationRegex)) {\n        // Line continues on next line.\n        var remainder = line.replace(lineContinuationRegex, '', 'g');\n        return { command: null, remainder: remainder };\n    }\n\n    command = splitCommand(line);\n    command.lineno = lineno;\n\n    var commandParserFn = commandParsers[command.name];\n    if (!commandParserFn) {\n        // Invalid Dockerfile instruction, but allow it and move on.\n        // log.debug('Invalid Dockerfile command:', command.name);\n        commandParserFn = parseString;\n    }\n\n    if (commandParserFn(command)) {\n        // Successfully converted the arguments.\n        command.raw = line;\n        delete command.rest;\n    }\n\n    return { command: command, remainder: '' };\n}\n\n/**\n * Parse dockerfile contents string and returns the array of commands.\n *\n * Supported options:\n * {\n *    includeComments: false,     // Whether to include comment commands.\n * }\n *\n * Each commands is an object with these possible properties:\n * {\n *   name: 'ADD',                 // The name of the command\n *   args: [ '.', '/srv/app' ],   // Arguments (can be array, string or map)\n *   lineno: 5,                   // Line number in the contents string.\n *   error: null                  // Only if there was an error parsing command\n * }\n *\n * @param contents {String}  The dockerfile file content.\n * @param options  {Object}  Configurable parameters.\n * @returns        {Array}   Array of command entries - one for each line.\n */\nfunction parse(contents, options) {\n    var commands = [];\n    var i;\n    var line;\n    var lineno;\n    var lines = contents.split(/\\r?\\n/);\n    var lookingForDirectives = true;\n    var parseOptions = {};\n    var parseResult;\n    var regexMatch;\n    var remainder = '';\n    var includeComments = options && options['includeComments'];\n\n    for (i = 0; i < lines.length; i++) {\n        lineno = i + 1;\n        var nextLine = lines[i];\n        // remove inline RUN # comment see https://github.com/joyent/node-docker-file-parser/issues/8\n        // if line will be continued, comments don't matter :=\n        if (line && line.match(TOKEN_LINE_CONTINUATION) && isComment(nextLine)) {\n            line = remainder + \"\\\\\";\n        } else if (remainder) {\n            line = remainder + nextLine;\n        } else {\n            line = nextLine;\n        }\n\n        if (lookingForDirectives) {\n            // Handle the parser directive '# escape=<char>. Parser directives\n            // must precede any builder instruction or other comments, and\n            // cannot be repeated.\n            regexMatch = line.match(TOKEN_ESCAPE_DIRECTIVE);\n            if (regexMatch) {\n                if (regexMatch[1] != '`' && regexMatch[1] != '\\\\') {\n                    throw new Error('invalid ESCAPE \"' + regexMatch[1]\n                        + '\". Must be ` or \\\\');\n                }\n                if (parseOptions.lineContinuationRegex) {\n                    throw new Error(\n                        'only one escape parser directive can be used');\n                }\n                parseOptions.lineContinuationRegex = RegExp(\n                    regexEscape(regexMatch[1]) + '[ \\t]*$');\n                continue;\n            }\n        }\n        // Once a comment, empty line or builder instruction has been processed,\n        // Docker no longer looks for parser directives.\n        lookingForDirectives = false;\n\n        parseResult = parseLine(line, lineno, parseOptions);\n        if (parseResult.command) {\n            if (parseResult.command.name !== 'COMMENT' || includeComments) {\n                commands.push(parseResult.command);\n            }\n        }\n        remainder = parseResult.remainder;\n    }\n\n    return commands;\n}\n\n\nmodule.exports = {\n    parse: parse\n};\n", "var parser = require('./parser');\n\nmodule.exports = {\n\tparse: parser.parse\n}\n"],
  "mappings": "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",
  "names": []
}
