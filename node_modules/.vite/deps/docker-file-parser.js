import {
  __commonJS
} from "./chunk-HKJ2B2AA.js";

// node_modules/docker-file-parser/parser.js
var require_parser = __commonJS({
  "node_modules/docker-file-parser/parser.js"(exports, module) {
    var TOKEN_WHITESPACE = RegExp(/[\t\v\f\r ]+/);
    var TOKEN_LINE_CONTINUATION = RegExp(/\\[ \t]*$/);
    var TOKEN_COMMENT = RegExp(/^\s*#.*$/);
    var TOKEN_ESCAPE_DIRECTIVE = RegExp(/^#[ \t]*escape[ \t]*=[ \t]*(.).*$/);
    var errDockerfileNotStringArray = new Error("When using JSON array syntax, arrays must be comprised of strings only.");
    function isSpace(s) {
      return s.match(/^\s$/);
    }
    function regexEscape(str) {
      return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
    }
    function parseSubCommand(cmd) {
      var parseDetails = parseLine(cmd.rest, cmd.lineno);
      if (parseDetails.command) {
        cmd.args = parseDetails.command;
        return true;
      }
      cmd.error = "Unhandled onbuild command: " + cmd.rest;
      return false;
    }
    function parseWords(rest) {
      var S_inSpaces = 1;
      var S_inWord = 2;
      var S_inQuote = 3;
      var words = [];
      var phase = S_inSpaces;
      var word = "";
      var quote = "";
      var blankOK = false;
      var ch;
      var pos;
      for (pos = 0; pos <= rest.length; pos++) {
        if (pos != rest.length) {
          ch = rest[pos];
        }
        if (phase == S_inSpaces) {
          if (pos == rest.length) {
            break;
          }
          if (isSpace(ch)) {
            continue;
          }
          phase = S_inWord;
        }
        if ((phase == S_inWord || phase == S_inQuote) && pos == rest.length) {
          if (blankOK || word.length > 0) {
            words.push(word);
          }
          break;
        }
        if (phase == S_inWord) {
          if (isSpace(ch)) {
            phase = S_inSpaces;
            if (blankOK || word.length > 0) {
              words.push(word);
            }
            word = "";
            blankOK = false;
            continue;
          }
          if (ch == "'" || ch == '"') {
            quote = ch;
            blankOK = true;
            phase = S_inQuote;
          }
          if (ch == "\\") {
            if (pos + 1 == rest.length) {
              continue;
            }
            word += ch;
            pos++;
            ch = rest[pos];
          }
          word += ch;
          continue;
        }
        if (phase == S_inQuote) {
          if (ch == quote) {
            phase = S_inWord;
          }
          if (ch == "\\" && quote != "'") {
            if (pos + 1 == rest.length) {
              phase = S_inWord;
              continue;
            }
            word += ch;
            pos++;
            ch = rest[pos];
          }
          word += ch;
        }
      }
      return words;
    }
    function parseNameVal(cmd) {
      var word;
      var words = parseWords(cmd.rest);
      cmd.args = {};
      if (words.length === 0) {
        cmd.error = "No KEY name value, or KEY name=value arguments found";
        return false;
      }
      if (words[0].indexOf("=") == -1) {
        var strs = cmd.rest.split(TOKEN_WHITESPACE);
        if (strs.length < 2) {
          cmd.error = cmd.name + " must have two arguments, got " + cmd.rest;
          return false;
        }
        cmd.args[strs[0]] = strs.slice(1).join(" ");
      } else {
        var i;
        for (i = 0; i < words.length; i++) {
          word = words[i];
          if (word.indexOf("=") == -1) {
            cmd.error = "Syntax error - can't find = in " + word + ". Must be of the form: name=value";
            return false;
          }
          var parts = word.split("=");
          cmd.args[parts[0]] = parts.slice(1).join("=");
        }
      }
      return true;
    }
    function parseEnv(cmd) {
      return parseNameVal(cmd);
    }
    function parseLabel(cmd) {
      return parseNameVal(cmd);
    }
    function parseNameOrNameVal(cmd) {
      cmd.args = parseWords(cmd.rest);
      return true;
    }
    function parseStringsWhitespaceDelimited(cmd) {
      cmd.args = cmd.rest.split(TOKEN_WHITESPACE);
      return true;
    }
    function parseString(cmd) {
      cmd.args = cmd.rest;
      return true;
    }
    function parseJSON(cmd) {
      try {
        var json = JSON.parse(cmd.rest);
      } catch (e) {
        return false;
      }
      if (!Array.isArray(json)) {
        return false;
      }
      if (!json.every(function(entry) {
        return typeof entry === "string";
      })) {
        return false;
      }
      cmd.args = json;
      return true;
    }
    function parseJsonOrString(cmd) {
      if (parseJSON(cmd)) {
        return true;
      }
      return parseString(cmd);
    }
    function parseJsonOrList(cmd) {
      if (parseJSON(cmd)) {
        return true;
      }
      return parseStringsWhitespaceDelimited(cmd);
    }
    var commandParsers = {
      "ADD": parseJsonOrList,
      "ARG": parseNameOrNameVal,
      "CMD": parseJsonOrString,
      "COPY": parseJsonOrList,
      "ENTRYPOINT": parseJsonOrString,
      "ENV": parseEnv,
      "EXPOSE": parseStringsWhitespaceDelimited,
      "FROM": parseString,
      "LABEL": parseLabel,
      "MAINTAINER": parseString,
      "ONBUILD": parseSubCommand,
      "RUN": parseJsonOrString,
      "STOPSIGNAL": parseString,
      "USER": parseString,
      "VOLUME": parseJsonOrList,
      "WORKDIR": parseString
    };
    function isComment(line) {
      return line.match(TOKEN_COMMENT);
    }
    function splitCommand(line) {
      var match = line.match(TOKEN_WHITESPACE);
      if (!match) {
        return { name: line.toUpperCase(), rest: "" };
      }
      var name = line.substr(0, match.index).toUpperCase();
      var rest = line.substr(match.index + match[0].length);
      return { name, rest };
    }
    function parseLine(line, lineno, options) {
      var command = null;
      var lineContinuationRegex = options && options.lineContinuationRegex || TOKEN_LINE_CONTINUATION;
      line = line.trim();
      if (!line) {
        return { command: null, remainder: "" };
      }
      if (isComment(line)) {
        command = { name: "COMMENT", args: line, lineno };
        return { command, remainder: "" };
      }
      if (line.match(lineContinuationRegex)) {
        var remainder = line.replace(lineContinuationRegex, "", "g");
        return { command: null, remainder };
      }
      command = splitCommand(line);
      command.lineno = lineno;
      var commandParserFn = commandParsers[command.name];
      if (!commandParserFn) {
        commandParserFn = parseString;
      }
      if (commandParserFn(command)) {
        command.raw = line;
        delete command.rest;
      }
      return { command, remainder: "" };
    }
    function parse(contents, options) {
      var commands = [];
      var i;
      var line;
      var lineno;
      var lines = contents.split(/\r?\n/);
      var lookingForDirectives = true;
      var parseOptions = {};
      var parseResult;
      var regexMatch;
      var remainder = "";
      var includeComments = options && options["includeComments"];
      for (i = 0; i < lines.length; i++) {
        lineno = i + 1;
        var nextLine = lines[i];
        if (line && line.match(TOKEN_LINE_CONTINUATION) && isComment(nextLine)) {
          line = remainder + "\\";
        } else if (remainder) {
          line = remainder + nextLine;
        } else {
          line = nextLine;
        }
        if (lookingForDirectives) {
          regexMatch = line.match(TOKEN_ESCAPE_DIRECTIVE);
          if (regexMatch) {
            if (regexMatch[1] != "`" && regexMatch[1] != "\\") {
              throw new Error('invalid ESCAPE "' + regexMatch[1] + '". Must be ` or \\');
            }
            if (parseOptions.lineContinuationRegex) {
              throw new Error(
                "only one escape parser directive can be used"
              );
            }
            parseOptions.lineContinuationRegex = RegExp(
              regexEscape(regexMatch[1]) + "[ 	]*$"
            );
            continue;
          }
        }
        lookingForDirectives = false;
        parseResult = parseLine(line, lineno, parseOptions);
        if (parseResult.command) {
          if (parseResult.command.name !== "COMMENT" || includeComments) {
            commands.push(parseResult.command);
          }
        }
        remainder = parseResult.remainder;
      }
      return commands;
    }
    module.exports = {
      parse
    };
  }
});

// node_modules/docker-file-parser/index.js
var require_docker_file_parser = __commonJS({
  "node_modules/docker-file-parser/index.js"(exports, module) {
    var parser = require_parser();
    module.exports = {
      parse: parser.parse
    };
  }
});
export default require_docker_file_parser();
//# sourceMappingURL=docker-file-parser.js.map
